## HTTP缓存

    HTTP缓存时前端开发中最常接触的缓存机制之一，可以分为两种：强制缓存、协商缓存。二者最大的区别在于判断缓存命中时，浏览器是否需要服务器端进行询问以协商缓存的相关信息，进而判断是否需要就响应内容进行重新请求

## 强制缓存

    只要在时限范围内，强制使用缓存，不需要询问浏览器。与强制缓存相关的两个字段是expires和cache-control响应头字段

1. 其中expires: new Date().toUTCString()，严重依赖本地时间，如果客户端时间和服务端时间不一致，或者用户更改了本地时间，那么会对缓存的判断造成误导

2. 为了解决上面的问题，又新增了cache-control字段，其中设置了max-age=(second)来设置从资源在被请求后的second秒内，缓存有效

## 协商缓存

    协商缓存是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期

用法之一：根据配置last-modified响应头字段，和cache-control字段。对请求文件的修改时间做一个判断。

值得注意的是，在初次配置last-modified字段后，第二次请求会发现请求头有If-Modified-Since字段，value是资源修改的时间。

last-modified的缺点：

1. 资源的名字发生了改变也会导致时间戳的变化，而实际上内容没有改变，这样会浪费网络带宽资源

2. 标识文件资源修改的时间戳单位是秒S，如果文件修改的速度特别快，例如几百毫秒内完成，那是不会导致时间戳的改变的



为了解决时间戳判断的不足，HTTP/1.1新增了ETag（Entity Tag）的头信息

ETag的值是根据服务器对不同的资源进行哈希运算所生成的一个字符串，因为是根据内容生成，所以屏蔽了修改文件名造成的缓存误判。

与last-modified类似，收到响应头的ETag字段后，第二次请求会在请求头附上If-None-Match字段，值就是上一次ETage的值
