## SSL/TLS

    https后面的s指的是SSL/TLS加密协议，SSL在现代浏览器大多数都不支持了，使用的都是TLS，但由于SSL名气大，所以现在也有人把它们混起来叫，或者就叫成SSL。这些其实都是不对的，下面的笔记都把TLS作为主要叫法

## 对称加密

    假定发送方和接收方事先规定一种别人都不知道的加密和解密算法G，那么理论上只有发送和接收方能正常进行通信，但如果由第三者不小心获取到了算法G，那么使用该算法的通信双方就相当于在别人面前裸奔了。

## 非对称加密

    为了避免上面出现的尴尬，非对称加密引入了公钥和私钥两个概念    

<img title="" src="file:///C:/Users/Crazy_pea/AppData/Roaming/marktext/images/2022-12-04-01-04-38-image.png" alt="" width="801">

小青有一把全世界只有他才有的青色钥匙，小红也是有一把独一无二的红色钥匙；他们两个决定把黄色钥匙公开出去，可以让别人看到这是我们要用到的钥匙；然后小青和小红用各自的私钥合并公开的公钥，两者都得到各自的私公钥结合体！并向对方交换；最后小青用小红给的结合体和自己的私钥再结合，小红也做相同的操作，结果发现都能合成一样的超级无敌独一无二钥匙。这就是非对称加密的过程

## TLS握手过程(TLS 1.2 简要版本)

    TLS握手是在TCP三次握手之后，也就是连接确认建立之后。

1. 客户端先向服务端打招呼: Client Hello 并且附带TLS版本，加密套件(有多种)，第1随机数

2. 服务端也向客户端打招呼: Server Hello 并且告知客户端选择的TLS版本，加密套件，第2随机数。同时，还有一系列的响应: Certificate（把自己的证书发过去），Server Key Exchange（把公钥发过去，如果需要客户端的证书也是在这里做请求），Server Hello Done（说完啦）

3. 客户端生成预主密钥（第3随机数），预主密钥将服务端发过来的公钥进行加密后再发回给服务端，并且发送Change Ciper Spec（告诉服务端TLS协商没问题了） Encrypted Handshake Message（加密开始）

4. 服务端收到用公钥加密后的预主密钥后，使用自己的私钥进行解密，这样就得到跟客户端那边一样的预主密钥了

5. 最后，双方将第1随机数+第2随机数+预主密钥计算出**会话密钥**（当然不是简单的加法）

6. 在得到会话密钥之前的步骤都是非对称加密，后面的通信都使用过会话密钥的对称加密通信，因为资源消耗太大了
