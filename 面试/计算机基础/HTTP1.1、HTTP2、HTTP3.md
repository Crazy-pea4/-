## HTTP1.1

**持久连接**：TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive



**管道机制**：与1.0版本相比，不需要发送一个请求等服务器回应后才能发下一个，在一个TCP连接中可以同时发多个请求，但服务器端必须要按发送的顺序来依次接收



**引入了`Content-length`字段**



**分块传输编码**：使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。因此，1.1版规定可以不使用Content-Length字段，而使用"分块传输编码"（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。



**HTTP/1.1支持文件断点续传**



<mark>缺点</mark>：可能造成队头堵塞，每次发送请求携带大量重复发送过的头部信息



## HTTP2

**多路复用**：为了避免HTTP1可能造成的“队头堵塞”，HTTP2.0使用了`多路复用的技术`，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级



**将报文拆分成首部帧和数据帧**：在每个帧中都有一个<mark>流标识符</mark>，使得帧可以不按顺序发送。在HTTP2中，并不是ASCII码的报文，而是提前转为二进制，效率更高



**压缩首部**：采用了Hpack压缩算法，HPACK算法要求浏览器和服务器都保存一张静态只渎的表。例如`HTTP1.1 200 OK`就换成了`:status: 200`，另外像cookie这样的首部可以作为动态信息加入动态表里



**服务器推送**：HTTP/2 允许服务器未经请求，主动向客户端发送资源。意思就是。简单来说，不像HTTP1.1时一样，问一句来一句，而是一个请求过来，相应的时候顺便把接下来要用要的都传回去，存在客户端某些地方以后本地加载即可，速度自然快。*但这种方式也有弊端，例如：用户不小心点错了某个网页，服务端一下子全都给你返回，造成不必要的浪费。*



<mark>缺点</mark>：HTTP2只是解决了应用层面的队头阻塞问题，但下面依然是传输层TCP传输，如果TCP传输丢失就只能等待重传（即使只是一行代码注释）。这就是**TCP层队头阻塞**



## HTTP3

谷歌基于UDP协议上开发了`QUIC`。 避免包阻塞：因为QUIDC协议为UDP协议，不同流的传输数据实现了互不干涉，不会导致一个数据丢包影响了整个流的传输

![](C:\Users\Crazy_pea\AppData\Roaming\marktext\images\2022-12-04-23-55-02-image.png)

从应用层过来的数据会在QUIC被封装成QUIC帧，相当于在传输层有了数据帧从源头解决问题，然后QUIC帧再次被封装成QUIC数据包。QUIC数据包会加上一些信息，最重要的是加上了Connection ID，在某些情况下避免了再次握手，速度很快快

![](C:\Users\Crazy_pea\AppData\Roaming\marktext\images\2022-12-05-00-06-27-image.png)

接着QUIC数据包被UDP封装成数据段


