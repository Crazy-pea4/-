## HTTP1.1

**持久连接**：TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive

**管道机制**：与1.0版本相比，不需要发送一个请求等服务器回应后才能发下一个，在一个TCP连接中可以同时发多个请求，但服务器端必须要按发送的顺序来依次接收

**引入了`Content-length`字段**

**分块传输编码**：使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。因此，1.1版规定可以不使用Content-Length字段，而使用"分块传输编码"（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。

**HTTP/1.1支持文件断点续传**

<mark>缺点</mark>：可能造成队头堵塞，每次发送请求携带大量重复发送过的头部信息

## HTTP2

**多路复用**：为了避免HTTP1可能造成的“队头堵塞”，HTTP2.0使用了`多路复用的技术`，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级

**将报文拆分成首部帧和数据帧**：在每个帧中都有一个<mark>流标识符</mark>，使得帧可以不按顺序发送。在HTTP2中，并不是ASCII码的报文，而是提前转为二进制，效率更高

**压缩首部**：采用了Hpack压缩算法，HPACK算法要求浏览器和服务器都保存一张静态只渎的表。例如`HTTP1.1 200 OK`就换成了`:status: 200`，另外像cookie这样的首部可以作为动态信息加入动态表里

**服务器推送**：HTTP/2 允许服务器未经请求，主动向客户端发送资源。意思就是。简单来说，不像HTTP1.1时一样，问一句来一句，而是一个请求过来，相应的时候顺便把接下来要用要的都传回去，存在客户端某些地方以后本地加载即可，速度自然快。*但这种方式也有弊端，例如：用户不小心点错了某个网页，服务端一下子全都给你返回，造成不必要的浪费。*

<mark>缺点</mark>：HTTP2只是解决了**应用层层面的**队头阻塞问题，但下面依然是传输层TCP传输，如果TCP传输丢失就只能等待重传（即使只是一行代码注释）。这就是**TCP层队头阻塞**，TCP协议是由操作系统内核实现的，不方便修改，于是就有了HTTP3

## HTTP3（QUIC说白了就是避开修改TCP的协议）

HTTP3把**TCP和TLS的握手过程整合到一起**了，在传输层和应用层之间插入一条协议`QUIC`

谷歌基于UDP协议上开发了`QUIC`。 避免包阻塞：因为QUIDC协议为UDP协议，不同流的传输数据实现了互不干涉，不会导致一个数据丢包影响了整个流的传输

<img src="file:///C:/Users/Crazy_pea/AppData/Roaming/marktext/images/2022-12-04-23-55-02-image.png" title="" alt="" width="738">

从应用层过来的数据会在QUIC被封装成QUIC帧，类似于HTTP2拆分成帧，也有流标识符。相当于在传输层有了帧的概念，解决了TCP修改麻烦的弊端（曲线救国）

然后QUIC帧再次被封装成QUIC数据包。QUIC数据包会加上一些信息，最重要的是加上了`Connection ID`，在某些情况下避免了再次握手，速度很快快 

![](C:\Users\Crazy_pea\AppData\Roaming\marktext\images\2022-12-05-00-06-27-image.png)

接着QUIC数据包被UDP封装成数据段，UDP加上端口号

![](C:\Users\Crazy_pea\AppData\Roaming\marktext\images\2023-03-09-22-28-46-image.png)

当我们选择HTTP3通信时，QUIC就像TCP那样开启连接，建立连接通道传输数据

![](C:\Users\Crazy_pea\AppData\Roaming\marktext\images\2023-03-09-22-29-43-image.png)
