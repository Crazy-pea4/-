## 流量控制

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成 TCP 可靠性的一方面。

### 流量控制由滑动窗口协议来实现。

滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方**返回的 ACK** 中会包含自己的**接收窗口的大小**，并且利用大小来控制发送方的数据发送。

接收方在Ack中记录自己还能接收的数据量大小 Advertisedwindow。

`AdvertisedWindow = MaxRcvBuffer – (LastByteRcvd -LastByteRead)`

随Ack回复到发送方。

### 接收方

lastByteRcvd: 从网络中到当前缓存数据流的最后一个字节编号

lastByteRead: 最后一次缓存读取的位置

Rwnd: 滑动窗口 == AdvertisedWindow

<img src="file:///C:/Users/Crazy_pea/AppData/Roaming/marktext/images/2023-03-10-01-17-41-image.png" title="" alt="" width="791">

## 发送方

lastByteSent: 最后一次发送的位置

lastByteAcked: 最后一次收到确认包的位置

发送方需要控制这 两个值之差 <= Rwnd 即可

<img src="file:///C:/Users/Crazy_pea/AppData/Roaming/marktext/images/2023-03-10-01-25-06-image.png" title="" alt="" width="832">

*流量控制引发的死锁？怎么避免死锁的发生？*

*当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。  
为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。*

## 拥塞控制

**拥塞发生前，可避免流量过快增长拖垮网络；拥塞发生时，唯一的选择就是降低流量**。主要使用4种方式完成拥塞控制：

1. 慢启动
2. 拥塞避免
3. 快重传
4. 快恢复

发送方维持的**cwnd** （congestion window）是用于拥塞处理的窗口大小，取决于网络状况，由发送方探查网络主动调整。

为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：

- 当cwnd<ssthresh时，使用慢开始算法。

- 当cwnd>ssthresh时，改用拥塞避免算法。

- 当cwnd=ssthresh时，慢开始与拥塞避免算法任意。

### 慢启动

每经过一个RTT（往返时延），拥塞窗口 **cwnd 就加倍**。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。

TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。

<img src="https://pic002.cnblogs.com/images/2010/125788/2010101120451114.jpg" title="" alt="" width="728">

### 拥塞避免

拥塞避免：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口 **cwnd加1** ，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

慢启动算法主要呈指数增长，粗犷型，速度快（“慢”是相对于一步到位而言的）；而拥塞避免算法主要呈线性增长，精细型，速度慢，但更容易在不导致拥塞的情况下，找到网络环境的cwnd最优值。

----

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限**ssthresh设置**为出现拥塞时的发送方窗口值的**一半**（但不能小于2）。

然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。

### 快重传和快恢复

快重传：当发送方连续收到3次以上的相同确认报文，则证明该确认报的下一报文丢失。快重传规定，发送方只要一连收到三个重复确认就应当**立即重传**对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。

<img title="" src="https://pic002.cnblogs.com/images/2010/125788/2010101122524670.jpg" alt="" width="724">

快恢复：其过程有以下两个要点：

<1>. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。*请注意：接下去不执行慢开始算法。*

<2>. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

<img src="https://pic002.cnblogs.com/images/2010/125788/2010101123101842.jpg" title="" alt="" width="732">

区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。
